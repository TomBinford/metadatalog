// TODO support symbol values?
.type Argument = Constant { value: number }
               | Variable { name: symbol }

.type ConstantList = [
    first: number,
    rest: ConstantList
]

.type ArgumentList = [
    first: Argument,
    rest: ArgumentList
]

.type Predicate = [
    name: symbol,
    arguments: ArgumentList
]

.type PredicateList = [
    first: Predicate,
    rest: PredicateList
]

.type HornClause = [
    head: Predicate,
    body: PredicateList
]

.type VariableList = [
    first: symbol,
    rest: VariableList
]

.type Substitution = [
    variable_name: symbol,
    value: number
]

.type SubstitutionList = [
    first: Substitution,
    rest: SubstitutionList
]

.decl extensional(hc: HornClause)
.output extensional

// parent(0, 1).
extensional([["parent", [$Constant(0), [$Constant(1), nil]]],
            nil]).
// ancestor(x, y) :- parent(x, y).
extensional([["ancestor", [$Variable("x"), [$Variable("y"), nil]]],
            [["parent", [$Variable("x"), [$Variable("y"), nil]]], nil]]).
// ancestor(x, y) :- ancestor(x, z), parent(z, y).
extensional([["ancestor", [$Variable("x"), [$Variable("y"), nil]]],
            [["ancestor", [$Variable("x"), [$Variable("z"), nil]]], [["parent", [$Variable("z"), [$Variable("y"), nil]]], nil]]]).

.decl body_argument(horn_clause: HornClause, argument: Argument, rest_args: ArgumentList, rest_preds: PredicateList)
// FIXME this won't include a rule if its first predicate has no arguments.
body_argument(horn_clause, arg, restargs, restpreds) :-
    extensional(horn_clause),
    horn_clause=[_1, [[_2, [arg, restargs]], restpreds]].
body_argument(horn_clause, arg, restargs, restpreds) :- body_argument(horn_clause, _, [arg, restargs], restpreds).
body_argument(horn_clause, arg, restargs, restpreds) :- body_argument(horn_clause, _, nil, [[_, [arg, restargs]], restpreds]).

.decl head_argument(horn_clause: HornClause, argument: Argument, rest_args: ArgumentList)
head_argument(horn_clause, arg, restargs) :-
    extensional(horn_clause),
    horn_clause=[[_1, [arg, restargs]], _2].
head_argument(horn_clause, arg, restargs) :- head_argument(horn_clause, _, [arg, restargs]).

// Report rules that contain a variable in the head that is not an
// argument of any predicate in the body.
.decl error_ungrounded_variable(ungrounded_variable: Argument, horn_clause: HornClause)
.output error_ungrounded_variable(IO=stdout, delimiter=" is ungrounded in ")
error_ungrounded_variable(ungrounded_var, horn_clause) :-
    head_argument(horn_clause, ungrounded_var, _),
    ungrounded_var=$Variable(_1),
    !body_argument(horn_clause, ungrounded_var, _, _).

// The set of extensional facts (but constants is in reverse order)
// No groundedness check necessary because extensional_fact_rev_(_, _, nil) will only exist when all arguments are constants.
.decl extensional_fact_rev_(predicate_name: symbol, constants: ConstantList, args_rest: ArgumentList)
extensional_fact_rev_(pname, nil, args) :- extensional([[pname, args], nil]).
extensional_fact_rev_(pname, [c, restcs], restargs) :- extensional_fact_rev_(pname, restcs, [$Constant(c), restargs]).

.decl extensional_fact_(predicate_name: symbol, constants: ConstantList, rev_constants: ConstantList)
extensional_fact_(pname, nil, revcs) :- extensional_fact_rev_(pname, revcs, nil).
extensional_fact_(pname, [c, restcs], revcs) :- extensional_fact_(pname, restcs, [c, revcs]).

.decl extensional_fact(predicate_name: symbol, constants: ConstantList)
extensional_fact(pname, cs) :- extensional_fact_(pname, cs, nil).

.output extensional_fact(IO=stdout)

// The set of variables that appear in the body of a rule. Duplicates may be present.
.decl rule_variables_(horn_clause: HornClause, variable_names: VariableList, rest_args: ArgumentList, rest_preds: PredicateList)
rule_variables_(hc, nil, args, restpreds) :- extensional(hc), hc = [_1, [[_2, args], restpreds]].
rule_variables_(hc, vnames, args, restpreds) :- rule_variables_(hc, vnames, nil, [[_, args], restpreds]).
rule_variables_(hc, vnames, restargs, restpreds) :- rule_variables_(hc, vnames, [$Constant(_), restargs], restpreds).
rule_variables_(hc, [vname, vnames], restargs, restpreds) :- rule_variables_(hc, vnames, [$Variable(vname), restargs], restpreds).

.decl rule_variables(horn_clause: HornClause, variable_names: VariableList)
rule_variables(hc, vnames) :- rule_variables_(hc, vnames, nil, nil).

// The deduplicated version of rule_variables. It's also in reverse
// order but that is irrelevant for substitutions.
// This is modeled after samples/deduplicate.dl.
.decl rule_variables_dedup_(horn_clause: HornClause, result: VariableList, tocheck: VariableList, todo: VariableList)
rule_variables_dedup_(hc, nil, nil, x) :- rule_variables(hc, x).
// When the top of tocheck has been seen before, leave output unchanged and consider the rest of tocheck.
rule_variables_dedup_(hc, r, nil, trest) :- rule_variables_dedup_(hc, r, [s, _], [s, trest]).
// When the top of todo was nowhere in result, move it to result.
rule_variables_dedup_(hc, [e, result], [e, result], trest) :- rule_variables_dedup_(hc, result, nil, [e, trest]).
// Keep looking when we haven't proved or disproved that the top of todo is in result.
rule_variables_dedup_(hc, r, tocheckrest, [e, trest]) :- rule_variables_dedup_(hc, r, [tocheck, tocheckrest], [e, trest]), tocheck != e.

.decl rule_variables_dedup(horn_clause: HornClause, result: VariableList)
rule_variables_dedup(hc, vnames) :- rule_variables_dedup_(hc, vnames, _, nil).

// The set of all constants in the program's facts.
.decl fact_constant_(constant: number, rest: ConstantList)
fact_constant_(c, crest) :- fact(_, [c, crest]).
fact_constant_(c, crest) :- fact_constant_(_, [c, crest]).

// The set of substitutions that can be applied for a particular rule.
// This is the starting point for bottom-up evaluation: generate all substitutions so later we can exhaustively try them.
.decl possible_substitution_(horn_clause: HornClause, subs: SubstitutionList, variables_rest: VariableList)
possible_substitution_(hc, nil, vars) :- rule_variables_dedup(hc, vars).
possible_substitution_(hc, [[vname, c], srest], vrest) :- possible_substitution_(hc, srest, [vname, vrest]), fact_constant_(c, _).

.decl possible_substitution(horn_clause: HornClause, subs: SubstitutionList)
possible_substitution(hc, subs) :- possible_substitution_(hc, subs, nil).

// The set of all facts in the metadatalog program, extensional and intensional.
// TODO the intensional part lol
.decl fact(predicate_name: symbol, constants: ConstantList)
fact(pname, cs) :- extensional_fact(pname, cs).
