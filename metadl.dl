// TODO support symbol values?
.type Argument = Constant { value: number }
               | Variable { name: symbol }

.type ConstantList = [
    first: number,
    rest: ConstantList
]

.type ArgumentList = [
    first: Argument,
    rest: ArgumentList
]

.type Predicate = [
    name: symbol,
    arguments: ArgumentList
]

.type PredicateList = [
    first: Predicate,
    rest: PredicateList
]

.type HornClause = [
    head: Predicate,
    body: PredicateList
]

.type VariableList = [
    first: symbol,
    rest: VariableList
]

.decl extensional(hc: HornClause)
.output extensional

// parent(0, 1).
extensional([["parent", [$Constant(0), [$Constant(1), nil]]],
            nil]).
// ancestor(x, y) :- parent(x, y).
extensional([["ancestor", [$Variable("x"), [$Variable("y"), nil]]],
            [["parent", [$Variable("x"), [$Variable("y"), nil]]], nil]]).
// ancestor(x, y) :- ancestor(x, z), parent(z, y).
extensional([["ancestor", [$Variable("x"), [$Variable("y"), nil]]],
            [["ancestor", [$Variable("x"), [$Variable("z"), nil]]], [["parent", [$Variable("z"), [$Variable("y"), nil]]], nil]]]).

.decl body_argument(horn_clause: HornClause, argument: Argument, rest_args: ArgumentList, rest_preds: PredicateList)
// FIXME this won't include a rule if its first predicate has no arguments.
body_argument(horn_clause, arg, restargs, restpreds) :-
    extensional(horn_clause),
    horn_clause=[_1, [[_2, [arg, restargs]], restpreds]].
body_argument(horn_clause, arg, restargs, restpreds) :- body_argument(horn_clause, _, [arg, restargs], restpreds).
body_argument(horn_clause, arg, restargs, restpreds) :- body_argument(horn_clause, _, nil, [[_, [arg, restargs]], restpreds]).

.decl head_argument(horn_clause: HornClause, argument: Argument, rest_args: ArgumentList)
head_argument(horn_clause, arg, restargs) :-
    extensional(horn_clause),
    horn_clause=[[_1, [arg, restargs]], _2].
head_argument(horn_clause, arg, restargs) :- head_argument(horn_clause, _, [arg, restargs]).

// Report rules that contain a variable in the head that is not an
// argument of any predicate in the body.
.decl error_ungrounded_variable(ungrounded_variable: Argument, horn_clause: HornClause)
.output error_ungrounded_variable(IO=stdout, delimiter=" is ungrounded in ")
error_ungrounded_variable(ungrounded_var, horn_clause) :-
    head_argument(horn_clause, ungrounded_var, _),
    ungrounded_var=$Variable(_1),
    !body_argument(horn_clause, ungrounded_var, _, _).

// The set of extensional facts (but constants is in reverse order)
// No groundedness check necessary because extensional_fact_rev_(_, _, nil) will only exist when all arguments are constants.
.decl extensional_fact_rev_(predicate_name: symbol, constants: ConstantList, args_rest: ArgumentList)
extensional_fact_rev_(pname, nil, args) :- extensional([[pname, args], nil]).
extensional_fact_rev_(pname, [c, restcs], restargs) :- extensional_fact_rev_(pname, restcs, [$Constant(c), restargs]).

.decl extensional_fact_(predicate_name: symbol, constants: ConstantList, rev_constants: ConstantList)
extensional_fact_(pname, nil, revcs) :- extensional_fact_rev_(pname, revcs, nil).
extensional_fact_(pname, [c, restcs], revcs) :- extensional_fact_(pname, restcs, [c, revcs]).

.decl extensional_fact(predicate_name: symbol, constants: ConstantList)
extensional_fact(pname, cs) :- extensional_fact_(pname, cs, nil).

.output extensional_fact(IO=stdout)

// The set of variables that appear in the body of a rule. Duplicates may be present.
.decl rule_variables_(horn_clause: HornClause, variable_names: VariableList, rest_args: ArgumentList, rest_preds: PredicateList)
rule_variables_(hc, nil, args, restpreds) :- extensional(hc), hc = [_1, [[_2, args], restpreds]].
rule_variables_(hc, vnames, args, restpreds) :- rule_variables_(hc, vnames, nil, [[_, args], restpreds]).
rule_variables_(hc, vnames, restargs, restpreds) :- rule_variables_(hc, vnames, [$Constant(_), restargs], restpreds).
rule_variables_(hc, [vname, vnames], restargs, restpreds) :- rule_variables_(hc, vnames, [$Variable(vname), restargs], restpreds).

.decl rule_variables(horn_clause: HornClause, variable_names: VariableList)
rule_variables(hc, vnames) :- rule_variables_(hc, vnames, nil, nil).

// The set of all facts in the metadatalog program, extensional and intensional.
// TODO the intensional part lol
.decl fact(predicate_name: symbol, constants: ConstantList)
fact(pname, cs) :- extensional_fact(pname, cs).
